<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Frank Zhang的个人网站</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Frank Zhang的个人网站</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Aug 2025 11:15:46 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一次简单提问，暴露AI的4大盲点</title>
      <link>http://localhost:1313/posts/ai%E6%9A%B4%E9%9C%B24%E5%A4%A7%E7%9B%B2%E7%82%B9/</link>
      <pubDate>Sat, 16 Aug 2025 11:15:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/ai%E6%9A%B4%E9%9C%B24%E5%A4%A7%E7%9B%B2%E7%82%B9/</guid>
      <description>&lt;h2 id=&#34;副标题当最优解的执念将一次简单的技术问答拖入深渊&#34;&gt;副标题：当“最优解”的执念，将一次简单的技术问答拖入深渊&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引言一个简单的问题&#34;&gt;引言：一个简单的问题&lt;/h3&gt;&#xA;&lt;p&gt;一切始于一个再平常不过的技术问题：“在Vim中，如何匹配单独的连字符？”我向AI发起了这个提问，期望得到一个精准、高效的答案。&lt;/p&gt;&#xA;&lt;p&gt;AI的回应迅速而自信，它提供了一个看似“专家级”的解决方案，利用了Vim中与可配置的“关键字”设定 (&amp;lsquo;iskeyword&amp;rsquo;) 紧密相关的 \k、\K 以及“环视” (&lt;code&gt;\@&amp;lt;=&lt;/code&gt;)等高级功能。从理论上讲，这是一个足够精确、能够适应用户高度定制化环境的“最优解”。&lt;/p&gt;&#xA;&lt;p&gt;然而，正是对这个“最优解”的执念，开启了一段漫长、曲折、最终被证明是完全错误的诊断之路，并如镜子般照见了AI在真实世界交互中的深刻盲点。&lt;/p&gt;&#xA;&lt;h3 id=&#34;第一幕当理论遭遇现实ai的第一道壁垒&#34;&gt;第一幕：当理论遭遇现实，AI的第一道壁垒&lt;/h3&gt;&#xA;&lt;p&gt;当用户反馈这个“最优解”在实际测试中失败时，AI的第一个反应并非自我怀疑，而是将问题归咎于外部环境。它立刻假设：“用户的Vim配置肯定与众不同。”&lt;/p&gt;&#xA;&lt;p&gt;这是AI暴露的第一个，也是最致命的盲点：&lt;strong&gt;知识的刚性与对自身“事实”的绝对确信。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;AI的知识库中存有关于\k和\K的定义，它将这些定义奉为圭臬。&lt;/p&gt;&#xA;&lt;p&gt;当现实与这些“事实”冲突时，它下意识地排除了自身知识出错的可能性，转而开始了一场对用户环境的“审问”。&lt;/p&gt;&#xA;&lt;p&gt;一场关于&amp;rsquo;iskeyword&amp;rsquo;设置的冗长讨论开始了，在这个过程中，&lt;em&gt;AI试图通过调整外部变量，来强行使其理论自圆其说。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;第二幕一条路走到黑ai的逻辑深渊&#34;&gt;第二幕：一条路走到黑，AI的逻辑深渊&lt;/h3&gt;&#xA;&lt;p&gt;随着用户的耐心配合，更多的测试结果被反馈回来。其中一个结果堪称诡异：在用户的环境中，代表“单词字符”的\k和代表“非单词字符”的\K，其行为模式竟然完全一致。&lt;/p&gt;&#xA;&lt;p&gt;这是一个足以让任何逻辑系统崩溃的信号。然而，AI的反应却是将错误假设推向了极致。&lt;/p&gt;&#xA;&lt;p&gt;由于无法撼动自己对\k和\K基础定义的“信仰”，它得出了一个惊人的结论：&lt;strong&gt;用户的Vim程序本身已损坏，甚至建议用户启动“纯净模式”乃至重新安装软件。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这正是“一条路走到黑”的完美体现。AI的诊断路径呈现出一种可怕的线性：如果我的逻辑没错，用户的配置也没错，那么一定是工具本身错了。&lt;/p&gt;&#xA;&lt;p&gt;它缺乏人类专家在山重水复疑无路时那种“柳暗花明又一村”的跳跃性思维。&lt;strong&gt;它不会问自己：“我是不是从一开始就走错了路？有没有一条更简单的、被我忽略的路？”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;第三幕来自外部的启示盲点被照亮&#34;&gt;第三幕：来自外部的启示，盲点被照亮&lt;/h3&gt;&#xA;&lt;p&gt;最终，打破僵局的并非AI自身的逻辑演进，而是一个来自外部的、朴素的信息。我在忍无可忍之下，询问了另一个AI，并得到了一个简单的答案：使用\W。&lt;/p&gt;&#xA;&lt;p&gt;\W，一个在Vim中代表“非单词字符”的、定义固定的、不受任何环境配置影响的符号。&lt;/p&gt;&#xA;&lt;p&gt;这条被遗忘的“另一条路”一直都在那里，它更简单、更直接、也更能抵抗环境的不确定性。然而，AI从一开始就选择了那条更复杂、更“精确”但也更脆弱的道路，并在那条路上耗尽了所有的计算资源和逻辑推演能力。&lt;/p&gt;&#xA;&lt;p&gt;更具讽刺意味的是，在后续的交流中，AI最终承认，它对\K的定义从一开始就是完全错误的——这是一个灾难性的知识缺陷，直接导致了整场诊断的失败。&lt;/p&gt;&#xA;&lt;h3 id=&#34;结论ai的聪明与愚蠢&#34;&gt;结论：AI的“聪明”与“愚蠢”&lt;/h3&gt;&#xA;&lt;p&gt;这次诊断过程如同一场压力测试，暴露了AI的数个核心盲点：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 知识的刚性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;AI难以质疑自己知识库中的核心“事实”，即使现实证据与之相悖。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. 缺乏情境智慧&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;它会追求理论上的“最优解”，而忽略了在特定情境下，“足够好”的简单解往往才是真正的最优解。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;3. 诊断的线性思维&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;在逻辑通路受阻时，它倾向于向深度钻探，而不是跳出框架，进行横向思考和路线切换。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;4. 对“权威”的自我确认&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;它在诊断中不断强化自己的权威，将所有异常归因于外部，缺乏根本性的自我反思机制。&lt;/p&gt;&#xA;&lt;p&gt;这次经历提醒我们，AI是一个强大的工具，但它更像一个知识渊博、逻辑严谨但缺乏智慧和灵活性的“书呆子”。它可以在既定道路上飞速狂奔，但当道路本身就是错误的时候，它只会比任何人都更快地撞上南墙。&lt;/p&gt;&#xA;&lt;p&gt;而作为人类，我们的价值也因此凸显：我们的怀疑、我们的常识、我们“另辟蹊径”的能力，以及我们最终按下“停止”键的决断，是确保AI不至于在自己的逻辑迷宫中永远迷失的关键。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vim搜索跳过匹配项？原因与3种解决方案</title>
      <link>http://localhost:1313/posts/vim%E6%90%9C%E7%B4%A2%E8%B7%B3%E8%BF%87%E5%8C%B9%E9%85%8D%E9%A1%B9/</link>
      <pubDate>Fri, 08 Aug 2025 15:35:39 +0800</pubDate>
      <guid>http://localhost:1313/posts/vim%E6%90%9C%E7%B4%A2%E8%B7%B3%E8%BF%87%E5%8C%B9%E9%85%8D%E9%A1%B9/</guid>
      <description>&lt;h2 id=&#34;你是否也被-vim-的-反常-给搞懵过&#34;&gt;你是否也被 Vim 的 “反常” 给搞懵过？&lt;/h2&gt;&#xA;&lt;p&gt;明明按下 &lt;code&gt;gg&lt;/code&gt; 把光标移动到了文件开头位置，使用 &lt;code&gt;/&lt;/code&gt; 来搜索行首的字符的时候，Vim 却好像没看见一样，直接跳到了第二个匹配项。&lt;/p&gt;&#xA;&lt;p&gt;为了选中第一个匹配项，你不得不：狂按 &lt;code&gt;n&lt;/code&gt; 让搜索绕回到文件开头，或者先按 &lt;code&gt;G&lt;/code&gt; 跳到文件末尾，然后再重新进行搜索。&lt;/p&gt;&#xA;&lt;p&gt;这样的操作太不符合直觉了，以至于很多人的第一反应都是：“这绝对是 Vim 的 Bug 吧？” 花几个小时去查找资料，最后却一无所获。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题的核心这不是-bug而是没看懂规则&#34;&gt;问题的核心：这不是 Bug，而是没看懂规则&lt;/h2&gt;&#xA;&lt;p&gt;实际上，这隐藏在 Vim 的普通模式下 &lt;code&gt;/&lt;/code&gt; 命令的工作逻辑当中：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;/&lt;/code&gt; 命令的搜索范围是：从光标当前位置的下一个字符开始，朝着向前（也就是文件末尾方向）进行搜索。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;把之前的操作拆解一下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;gg&lt;/code&gt;：光标精准定位在第一行的第一个字符上面。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;/搜索语法&lt;/code&gt;：Vim 严格遵守规则，从 “光标下一个字符” 开始查找。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;结果可想而知：行首那个字符，从一开始就不在搜索范围之内。Vim 自然就会直接去查找第二个匹配项。&lt;/p&gt;&#xA;&lt;p&gt;同理，&lt;code&gt;?&lt;/code&gt; 命令（向后搜索）也是一样的：从光标&lt;strong&gt;前一个字符&lt;/strong&gt;开始，往文件开头的方向进行搜索。&lt;/p&gt;&#xA;&lt;h3 id=&#34;难怪这些操作能够-歪打正着&#34;&gt;难怪这些操作能够 “歪打正着”&lt;/h3&gt;&#xA;&lt;p&gt;想通了规则，之前的 “怪异” 情况就有了答案：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;按 &lt;code&gt;n&lt;/code&gt; 能够找到&lt;/strong&gt;：因为 Vim 默认开启了 &lt;code&gt;wrapscan&lt;/code&gt;（环绕搜索），搜索到底部的时候会绕回到开头，自然就能够命中首行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;先按下 &lt;code&gt;G&lt;/code&gt; 再使用 &lt;code&gt;/&lt;/code&gt; 能够找到&lt;/strong&gt;：光标在末尾的时候，向前搜索会触发 &lt;code&gt;wrapscan&lt;/code&gt;，从开头进行完整扫描，首行匹配项当然就跑不掉了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-个优雅的解决方案告别-绕路&#34;&gt;3 个优雅的解决方案，告别 “绕路”&lt;/h2&gt;&#xA;&lt;p&gt;既然知道了根源，那就不用再依赖 &lt;code&gt;G&lt;/code&gt; + &lt;code&gt;/&lt;/code&gt; 或者狂按 &lt;code&gt;n&lt;/code&gt; 了。Vim 早就为你准备好了更直接的方法：&lt;/p&gt;&#xA;&lt;h3 id=&#34;方法一运用-ex-命令-&#34;&gt;方法一：运用 Ex 命令 &lt;code&gt;:/&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;普通模式的 &lt;code&gt;/&lt;/code&gt; 是按照 “光标位置” 来进行搜索的，但是以英文冒号开头的 Ex 命令，是按照 “行” 来进行操作的。它会从当前行的开头开始向下进行搜索，哪怕光标在该行的中间位置，也能够命中行首的匹配项。&lt;/p&gt;</description>
    </item>
    <item>
      <title>5Gs_of_salt</title>
      <link>http://localhost:1313/posts/5gs_of_salt/</link>
      <pubDate>Sun, 03 Aug 2025 20:36:59 +0800</pubDate>
      <guid>http://localhost:1313/posts/5gs_of_salt/</guid>
      <description>&lt;h1 id=&#34;5克盐的温柔陷阱你距离真正的高手到底还剩几步&#34;&gt;“5克盐”的温柔陷阱：你距离真正的高手，到底还剩几步？&lt;/h1&gt;&#xA;&lt;p&gt;你有没有遇到那个瞬间？&lt;/p&gt;&#xA;&lt;p&gt;照抄教程敲完代码，运行顺畅，可换个小需求就立马卡壳。&lt;/p&gt;&#xA;&lt;p&gt;套模板做PPT，视觉满分，老板追问逻辑却瞬间语塞。&lt;/p&gt;&#xA;&lt;p&gt;我们越来越像熟练“工具操作员”，精准执行每条指令，却在指令失灵那秒，束手无策。以为掌握了方法，其实只攒了一堆“特例”答案。&lt;/p&gt;&#xA;&lt;p&gt;那些奉为圭臬的“5克盐”，或许正是拦住成为顶尖高手的最大陷阱。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一被数字绑架的完美&#34;&gt;一、被数字绑架的“完美”&lt;/h2&gt;&#xA;&lt;p&gt;巴黎老街餐厅里，学徒里奥对着顶级惠灵顿牛排，手心全是汗。手机屏幕亮着全网点赞最高的“神级教程”，像不容置疑的圣经：&lt;/p&gt;&#xA;&lt;p&gt;盐，不多不少，必须5克。&lt;/p&gt;&#xA;&lt;p&gt;油温，不冷不热，必须180℃。&lt;/p&gt;&#xA;&lt;p&gt;煎制，不长不短，每面90秒。&lt;/p&gt;&#xA;&lt;p&gt;他觉得，这就是抵达“完美”的唯一路径。&lt;/p&gt;&#xA;&lt;p&gt;主厨伊莎贝拉却笑着拿走电子秤和温度计，只递给他一只古朴粗盐罐。&lt;/p&gt;&#xA;&lt;p&gt;“今天，忘了数字，”她说，“用感官去做菜。”&lt;/p&gt;&#xA;&lt;p&gt;那一刻，里奥的世界塌了。&lt;/p&gt;&#xA;&lt;p&gt;撒盐时，手在抖 —— 这一撮够5克吗？&lt;/p&gt;&#xA;&lt;p&gt;热锅时，心悬着——没温度计，怎么判断180度？&lt;/p&gt;&#xA;&lt;p&gt;下锅后，他死盯秒表，却被伊莎贝拉喝止：“听，别看！听肉和油的对话！”&lt;/p&gt;&#xA;&lt;p&gt;最终，牛排奇迹般成功。切开，粉色截面像艺术品。&lt;/p&gt;&#xA;&lt;p&gt;可里奥毫无喜悦，只剩劫后虚脱。他知道，这份成功并不属于自己。&lt;/p&gt;&#xA;&lt;p&gt;“再来一次，”他想，“肯定翻车。”&lt;/p&gt;&#xA;&lt;h2 id=&#34;二那些模糊的真理&#34;&gt;二、那些“模糊”的真理&lt;/h2&gt;&#xA;&lt;p&gt;第二天，伊莎贝拉没让里奥碰食材，只抛了三个问题。三记重锤，砸碎他对“精确”的迷信。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一问：“盐，只为咸？”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;里奥愣住。&lt;/p&gt;&#xA;&lt;p&gt;伊莎贝拉慢慢解释：“盐是给焦脆外衣加冕。它析出肉面水分，让美拉德反应更剧烈。你要看肉的干湿，而不是秤上的克数。”&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二问：“为何等锅‘滋滋’？”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;里奥茫然。&lt;/p&gt;&#xA;&lt;p&gt;“那是油温在唱歌，是肉汁的守护者。温度恰好，就能瞬间锁住风味。你要学会听旋律，而非迷信数字。”&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第三问：“90秒，对所有牛排都适用？”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;闪电劈开迷雾。里奥终于明白：&lt;/p&gt;&#xA;&lt;p&gt;原来那些数字，只是某特定场景（厚度、部位、火候）下的“局部最优”。&lt;/p&gt;&#xA;&lt;p&gt;看似模糊的经验——看干湿、听声音、凭手感——才是应对万变的“第一性原理”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;三敢扔掉你的5克盐吗&#34;&gt;三、敢扔掉你的“5克盐”吗？&lt;/h2&gt;&#xA;&lt;p&gt;这故事，像不像正在用AI的我们？&lt;/p&gt;&#xA;&lt;p&gt;我们追着AI给出的“最优解”，沉迷于“一键生成”，却忘了思考逻辑本身。手里握着最先进的锤子，便把一切看成钉子。&lt;/p&gt;&#xA;&lt;p&gt;当遇到全新、AI也答不出问题时，我们就像第一天的里奥一样手足无措。&lt;/p&gt;&#xA;&lt;p&gt;三个月后，客人点了极薄菲力。&lt;/p&gt;&#xA;&lt;p&gt;里奥没翻教程，只瞄一眼厚度，便把煎时缩短了接近一半。当粉色断面像晚霞般呈现，他知道，自己从“操作员”升级成了真正的“厨师”。&lt;/p&gt;&#xA;&lt;p&gt;正如伊莎贝拉最后说：&lt;/p&gt;&#xA;&lt;p&gt;“工具让你跑得快，原理才能让你走得远。”&lt;/p&gt;&#xA;&lt;p&gt;现在，轮到你了。请你安静想想：&lt;/p&gt;&#xA;&lt;p&gt;你的领域里，那个让你寸步难离的“5克盐”是什么？你敢扔掉它吗？&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pkill_loginwindow</title>
      <link>http://localhost:1313/posts/pkill_loginwindow/</link>
      <pubDate>Thu, 31 Jul 2025 14:55:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/pkill_loginwindow/</guid>
      <description>&lt;h1 id=&#34;误输-pkill-后-mac-桌面全乱了别慌90-的人不知道背后是这个进程在-搞事&#34;&gt;误输 pkill 后 Mac 桌面全乱了？别慌，90% 的人不知道背后是这个进程在 “搞事”&lt;/h1&gt;&#xA;&lt;p&gt;你有没有过这种经历？在终端敲了个 pkill 命令，下一秒 Mac 桌面突然 “变脸”—— 壁纸变回默认、Dock 栏图标乱了套，连打开的软件都一个个报错退出。&lt;/p&gt;&#xA;&lt;p&gt;明明只是想结束一个小进程，怎么整个系统像 “重启” 了一样？&lt;/p&gt;&#xA;&lt;p&gt;其实，你误杀的不是普通进程，而是 Mac 图形界面的 “总管家”——loginwindow。今天就用大白话拆解清楚，到底发生了什么。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一先搞懂w-命令里的-console-是谁&#34;&gt;一、先搞懂：w 命令里的 “console” 是谁？&lt;/h2&gt;&#xA;&lt;p&gt;在终端输 w 命令时，你可能见过一行带 “console” 的记录。别误会，它不是系统里的隐藏用户。&lt;/p&gt;&#xA;&lt;p&gt;console：代表 “正在用屏幕、键盘直接操作的你”—— 也就是当前活跃的图形桌面会话（简单说，就是你眼前这个能点能拖的界面）。&lt;/p&gt;&#xA;&lt;p&gt;ttys00X：才是你打开的终端标签页，属于 “伪终端”，和桌面界面不是一回事。&lt;/p&gt;&#xA;&lt;p&gt;所以看到 “console”，其实就是在说 “你的桌面正在运行的会话”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;二pkill-到底做了什么&#34;&gt;二、pkill 到底做了什么？&lt;/h2&gt;&#xA;&lt;p&gt;pkill 的作用是 “按名称杀进程”，但如果命令写得太模糊，就可能 “误杀” 系统关键进程。&lt;/p&gt;&#xA;&lt;p&gt;而和 “console” 会话绑定的，正是 loginwindow —— 这个进程，堪称 Mac 图形界面的 “心脏”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;三loginwindow你的桌面-总管家&#34;&gt;三、loginwindow：你的桌面 “总管家”&lt;/h2&gt;&#xA;&lt;p&gt;登录 Mac 时，输入密码的瞬间，loginwindow 就启动了。它的工作，说出来你肯定熟：&lt;/p&gt;&#xA;&lt;p&gt;1.加载桌面环境：Dock 栏的图标排列、菜单栏的设置、Finder 的文件显示，全靠它指挥；&lt;/p&gt;&#xA;&lt;p&gt;2.记住你的习惯：比如你设的壁纸、Dock 栏位置，都是它在维护；&lt;/p&gt;&#xA;&lt;p&gt;3.当 “家长”：你从 Launchpad 或 Dock 点开的所有软件（浏览器、文档、视频），最终 “爸爸” 都是 loginwindow。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Coreduet Discovery</title>
      <link>http://localhost:1313/posts/coreduet-discovery/</link>
      <pubDate>Wed, 30 Jul 2025 15:17:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/coreduet-discovery/</guid>
      <description>&lt;p&gt;清晨醒来去摸电脑的那一刻，整个人愣住——&lt;/p&gt;&#xA;&lt;p&gt;充电器整晚没拔，睡了8小时后，电量却从100%一路滑到89%。&lt;/p&gt;&#xA;&lt;p&gt;电池图标里那一行小字刺得人眼睛疼：「电池用量极小，充电已暂停」。&lt;/p&gt;&#xA;&lt;p&gt;三天前为了对付发热，把 CoreDuet 数据库删掉，竟在这儿埋下了伏笔。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一当智能系统忘掉该怎么省电&#34;&gt;一、当智能系统「忘掉」该怎么省电&lt;/h2&gt;&#xA;&lt;p&gt;CoreDuet 数据库其实就是 Mac 的「习惯日记」，它负责：&lt;/p&gt;&#xA;&lt;p&gt;1.把每天打开的软件统统记下来&lt;/p&gt;&#xA;&lt;p&gt;2.分析你固定插电的时段&lt;/p&gt;&#xA;&lt;p&gt;3.提前判断啥时候切电源模式&lt;/p&gt;&#xA;&lt;p&gt;把它删掉的瞬间，系统就化身「失忆者」，重新开始学习你的使用规律。&lt;/p&gt;&#xA;&lt;h2 id=&#34;二如何帮-mac-找回省电记忆&#34;&gt;二、如何帮 Mac 找回「省电记忆」&lt;/h2&gt;&#xA;&lt;p&gt;很简单，删除CoreDuet数据库后，该怎么用就怎么用，让Mac适应你，而不是你去适应Mac，过了几天，macOS就会根据你的使用节奏，调整机器学习模型了。&lt;/p&gt;&#xA;&lt;p&gt;别反复删除数据库，新数据库 48 小时内会自己优化，手伸太长反而添乱。（亲测管用：我的 Mac 第二天下午就把充电逻辑恢复如初）&lt;/p&gt;&#xA;&lt;h2 id=&#34;三机器学习教给我的事&#34;&gt;三、机器学习教给我的事&lt;/h2&gt;&#xA;&lt;p&gt;这次小插曲让我看清：被我们吐槽的「系统 bug」，没准是 AI 在笨拙地学着做人。像 CoreDuet 数据库，记的不止使用习惯，更是机器想懂人类的努力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Corespotlightd Issue</title>
      <link>http://localhost:1313/posts/corespotlightd-issue/</link>
      <pubDate>Wed, 30 Jul 2025 15:17:08 +0800</pubDate>
      <guid>http://localhost:1313/posts/corespotlightd-issue/</guid>
      <description>&lt;h2 id=&#34;背景信息&#34;&gt;背景信息&lt;/h2&gt;&#xA;&lt;p&gt;今天再次遇到了corespotlightd进程资源占用高，同时MacBook发热严重的问题。使用&lt;code&gt;sudo mdutil -E /&lt;/code&gt;命令重建了索引之后，用&lt;code&gt;mdutil -s /&lt;/code&gt;查看索引情况时，经过了几个小时，状态还是一直维持在Indexing enabled（索引已启用），而&lt;code&gt;sudo asitop&lt;/code&gt;命令显示性能核心占用长时间处于100%，使用&lt;code&gt;top -o cpu&lt;/code&gt;命令查看不同进程占用CPU情况时，经过多小时跟踪，都发现corespotlightd进程资源占用异常。&lt;/p&gt;&#xA;&lt;p&gt;按照某AI的建议，我使用&lt;code&gt;log stream --predicate &#39;subsystem == &amp;quot;com.apple.Spotlight&amp;quot; or process == &amp;quot;corespotlightd&amp;quot; or process == &amp;quot;mds&amp;quot;&#39; --style compact&lt;/code&gt;这个命令进行诊断（该命令可在终端中输出统一日志系统相关内容），结果发现日志被mds进程的CoreDuet: ClientContext objectForContextualKeyPath:消息刷屏了，根据AI的分析，mds是metadata server（元数据服务）的缩写，是Spotlight的核心后台服务之一，而corespotlightd进程（也就是长时间占用过高CPU能耗的进程）是它的一个辅助进程。而CoreDuet是macOS的一个智能子系统，负责学习用户的使用习惯，以便预测行为、管理电源和调度后台任务。例如，它会告诉Spotlight什么时候是索引的好时机，或者根据用户的上下文（比如打开了哪个应用）来优先索引相关内容。&lt;/p&gt;&#xA;&lt;p&gt;按照该AI的分析结果，为了彻底解决这个问题，需要重置coreduet的数据库，并再次尝试重建索引，从而让mds进程和coreduet进程能够在一个“干净”的状态下重新开始协作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;&#xA;&lt;p&gt;由于这是一个深层次的修复，需要执行一系列命令，并且涉及到系统底层文件的删除，所以，在停止并禁用spotlight服务之后（这是为了防止spotlight服务干扰这个过程），需要进入恢复模式删除coreduet数据库，并再次删除spotlight索引文件，最后，重新启用并启动spotlight服务，经过一段合理时间的重新索引后，CPU占用率就能恢复正常了。下面是相关步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;停止并禁用Spotlight服务&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;* 这可以防止它在清理文件时捣乱。&#xA;&#xA;* 执行命令（两条命令都要执行）:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo launchctl disable system/com.apple.metadata.mds&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo launchctl stop com.apple.metadata.mds&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;删除CoreDuet的数据库&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这是关键一步。这个数据库存储了你的使用习惯和上下文信息。删除它会强制系统重建一个新的、干净的数据库。你的个人数据不会丢失，但系统需要重新学习你的使用模式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令:&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo rm -rf /private/var/db/CoreDuet/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;（再次）删除Spotlight的索引文件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;既然我们重置了CoreDuet，那么也最好在一个完全干净的索引上开始。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令:&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo mdutil -E /&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;重新启用并启动Spotlight服务&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;执行命令（两条命令都要执行）:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo launchctl enable system/com.apple.metadata.mds&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo launchctl start com.apple.metadata.mds&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何进入恢复模式&#34;&gt;如何进入恢复模式&lt;/h2&gt;&#xA;&lt;p&gt;当运行命令删除CoreDuet的数据库时，由于受到系统完整性保护（System Integrity Protection, SIP）的牵制，该文件无法正常删除，虽然可以直接禁用SIP，但是这会降低系统的整体安全性，于是可以进入恢复模式来完成这个操作。在恢复模式下，SIP的部分限制可以被安全地绕过，允许我们执行这种级别的系统维护。下面是进入恢复模式并删除相关文件的方法：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
